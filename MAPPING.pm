#------------------------------------------------------------------------------
# CancerRNASeq - a pipeline for transcriptomics datasets
# Author: Raphael Hablesreiter
#
# MAPPING.pm
#          
# Description: Mapping Module
#              In the mapping module the mapping of the reads to the reference
#              genome is performed. The alignment of the reads can be 
#              generated by TopHat2, STAR or HISAT2.
#              This module also generates the specific index for the chosen
#              alignment tool, if it is not already been done in a previous run.    
# 
#-------------------------------------------------------------------------------
#

package MAPPING;

use 5.010;
use strict;
use warnings;

use Backticks;

use PIPELINETOOLS;

#-------------------------------------------------------------------------------
# Main: Starts either mapping of the sequences with Tophat or STAR, which one
#       of this two mapping options is started is provided in the user
#       configuration file.
#       
#-------------------------------------------------------------------------------
sub Main{
    
    my $i = $_[0];
    
    if ($i == 1 && $::global_cfg -> param("required.MappingType") eq "Tophat")
    {
        MAPPING::CreateReferenceGenomeTopHat();
        MAPPING::RunTophat();
    }
    elsif ($i == 1 && $::global_cfg -> param("required.MappingType") eq "STAR")
    {
        MAPPING::CreateReferenceGenomeStar();
        MAPPING::RunStar();
    }
    elsif ($i == 1 && $::global_cfg -> param("required.MappingType") eq "HISAT2")
    {
        MAPPING::CreateReferenceGenomeHISAT();
        MAPPING::RunHISAT();
        
    }
    elsif ($i == 2)
    {
       MAPPING::QualiMap(); 
    }
    else
    {
        die "ERROR: In Mapping.pm";
    }
    
    return;    
}

#-------------------------------------------------------------------------------
# CreateReferenceGenomeTopHat: This function creates the command for a proper
#           call of Bowtie-Build and then starts Bowtie-Build, but first
#           it checks if the index is already available
#-------------------------------------------------------------------------------
sub CreateReferenceGenomeTopHat{
    PIPELINETOOLS::WriteLogChapter("Create Reference Genome");
    my $status = 0;
    
    my $bowtiebuild_dir = $::global_cfg -> param("sprograms.BowTie2Build");
    my $ref_fasta = $::global_cfg -> param("required.GenomeFASTA");
    my $ref_name = $::global_cfg -> param("required.ReferenceGenome");
    my $raw_dir = $::global_cfg -> param("sdirectories.RawData");   
    my $ref_dir = $raw_dir."/TOPHATindex/".$ref_name;
    $::global_cfg -> param("results.THindex", $ref_dir."/".$ref_name);
    
    my @refgen_parts =
        (".1.bt2", ".2.bt2", ".3.bt2", ".4.bt2", ".rev.1.bt2", ".rev.1.bt2",
         ".fa");
    
    if (-d $ref_dir)
    {
        while (@refgen_parts)
        {
            if (!
             -e($::global_cfg -> param("results.THindex")).(pop(@refgen_parts)))
            {
                $status = $status + 1;            
            }    
        }
    }
    else
    {
        
        $status = $status + 1;
    }
    
    #checks if there's a genome reference file available
    if ($status != 0)
    {
        PIPELINETOOLS::PrintTask(
            "Started Generating Reference Genome For Tophat Alignment");
        my $cmd = `mkdir -p $ref_dir`;
        if ($cmd -> success() != 1)
        {
            PIPELINETOOLS::PrintStd($cmd -> merged);
            PIPELINETOOLS::WriteLogOut(($cmd -> merged));
            die "ERROR: mkdir\n";
        }
        
        $cmd = `cp $ref_fasta $ref_dir`;
        if ($cmd -> success() != 1)
        {
            die "ERROR: Can't copy Fasta File\n";
        }   
        
        $ref_fasta = $ref_dir."/".$ref_fasta;
        
        if ($ref_fasta =~ ".gz")
        {
            my $gunzip_cmd = `gunzip $ref_fasta`;
            if ($gunzip_cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                die "ERROR: Can't unzip $ref_fasta !\n";
            } 
            
            $ref_fasta = substr($ref_fasta,0,-3);
        }
        
        my $bowtiebuild_cmd = $bowtiebuild_dir." -f ".$ref_fasta." ".
            ($::global_cfg -> param("results.THindex"));
    
        $cmd = `$bowtiebuild_cmd`;
        if ($cmd -> success() != 1)
        {
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            die "ERROR: Can't build BowTie Index!\n";
        } 
        
        my $mv_cmd = "mv ".$ref_fasta." ".
            ($::global_cfg -> param("results.THindex")).".fa";
        $cmd = `$mv_cmd`;
        if ($cmd -> success() != 1)
        {
            PIPELINETOOLS::PrintStd($cmd -> merged);
            PIPELINETOOLS::WriteLogOut(($cmd -> merged));
            die "ERROR: Can't rename GenomeFasta-File!\n";
        }
        
        PIPELINETOOLS::WriteLogOut($cmd -> stdout);  
        PIPELINETOOLS::PrintTask(
            "Finished Generating Reference Genome For Tophat Alignment");
    }
    
    return;
}

#-------------------------------------------------------------------------------
# CreateReferenceGenomeStar: This function creates the command for a proper
#           call of STAR genomeGenerate and then starts STAR, but first
#           it checks if the index is already available
#-------------------------------------------------------------------------------
sub CreateReferenceGenomeStar{
    PIPELINETOOLS::WriteLogChapter("Create Reference Genome");
    my $status = 0;
    
    my $raw_dir = $::global_cfg -> param("sdirectories.RawData"); 
    my $ref_fasta = $::global_cfg -> param("required.GenomeFASTA");
    my $ref_name = $::global_cfg -> param("required.ReferenceGenome");  
    my $ref_dir = $raw_dir."/STARindex/".$ref_name;
    my $ref_gtf = $::global_cfg -> param("required.GenomeGTF");
    
    my @refgen_parts =
        ("Genome", "SA", "SAindex", "chrLength.txt", "chrName.txt",
         "chrNameLength.txt", "chrStart.txt", "exonGeTrInfo.tab",
         "exonInfo.tab", "geneInfo.tab", "genomeParameters.txt",
         "sjdbInfo.txt", "sjdbList.fromGTF.out.tab", "sjdbList.out.tab",
         "transcriptInfo.tab");
    
    if (-d $ref_dir)
    {
        while (@refgen_parts)
        {
            if (!-e $ref_dir."/".(pop(@refgen_parts)))
            {
                $status = $status + 1;            
            }    
        }
    }
    else
    {
        $status = $status + 1;
    }
    
    if ($status != 0)
    {
        PIPELINETOOLS::PrintTask(
            "Started Generating Reference Genome For STAR Alignment");
        my $cp_cmd = "mkdir -p ".$ref_dir;
        my $cmd = `$cp_cmd`;
        if ($cmd -> success() != 1)
        {
            PIPELINETOOLS::PrintStd($cmd -> merged);
            die "ERROR: mkdir\n";
        } 
        
        $cp_cmd = "cp ".$ref_fasta." ".$ref_dir;
        $cmd = `$cp_cmd`;
        if ($cmd -> success() != 1)
        {
            PIPELINETOOLS::PrintStd($cmd -> merged);
            die "ERROR: Can't move reference fasta file";
        } 
        
        $cp_cmd = "cp ".$ref_gtf." ".$ref_dir;
        $cmd = `$cp_cmd`;
        if ($cmd -> success() != 1)
        {
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            die "ERROR: Can't move reference gtf file";
        }
        
        $ref_fasta = $ref_dir."/".$ref_fasta;
        $ref_gtf = $ref_dir."/".$ref_gtf;
        
        if ($ref_fasta =~ ".gz")
        {
            my $gunzip_cmd = `gunzip $ref_fasta`;
            if ($gunzip_cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                die "ERROR: Can't unzipt $ref_fasta !\n";
            }
            
            $ref_fasta = substr($ref_fasta,0,-3);
        }
        
        if ($ref_gtf =~ ".gz")
        {
            my $gunzip_cmd = `gunzip $ref_gtf`;
            if ($gunzip_cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> stdout);
                die "ERROR: Can't unzipt $ref_gtf !\n";
            }
            
            $ref_gtf = substr($ref_gtf,0,-3);
        }
        
        my $STARbuild_cmd = ($::global_cfg -> param("sprograms.STAR")).
            " --runMode genomeGenerate --genomeDir ".$ref_dir.
            " --genomeFastaFiles ".$ref_fasta." --sjdbGTFfile ".$ref_gtf.
            " --sjdbOverhang 74 --runThreadN ".
            ($::global_cfg -> param("cmdline.threads"));
        
        $cmd = `$STARbuild_cmd`;
        if ($cmd -> success() != 1)
        {
            PIPELINETOOLS::PrintStd($cmd -> merged);
            PIPELINETOOLS::WriteLogOut(($cmd -> merged));
            die "ERROR: Can't build STARindex!\n";
        }
        PIPELINETOOLS::WriteLogOut($cmd -> stdout);

        unlink $ref_fasta;
        unlink $ref_gtf;
        
        PIPELINETOOLS::PrintTask(
            "Finished Generating Reference Genome For STAR Alignment");
    }
    
    return;
}

#-------------------------------------------------------------------------------
# CreateReferenceGenomeStar: This function creates the command for a proper
#           call of STAR genomeGenerate and then starts STAR, but first
#           it checks if the index is already available
#-------------------------------------------------------------------------------
sub CreateReferenceGenomeHISAT{
    PIPELINETOOLS::WriteLogChapter("Create Reference Genome");
    my $status = 0;
    
    my $raw_dir = $::global_cfg -> param("sdirectories.RawData"); 
    my $ref_fasta = $::global_cfg -> param("required.GenomeFASTA");
    my $ref_name = $::global_cfg -> param("required.ReferenceGenome");  
    my $ref_gtf = $::global_cfg -> param("required.GenomeGTF");
    my $ref_dir = $raw_dir."/HISATindex/".$ref_name;
    $::global_cfg -> param("results.HISATindex", $ref_dir."/".$ref_name);
    
    my @refgen_parts =
        (".1.ht2",".2.ht2",".3.ht2",".4.ht2",
         ".5.ht2",".6.ht2",".7.ht2",".8.ht2",);
    
    if (-d $ref_dir)
    {
        while (@refgen_parts)
        {
            if (!-e $ref_dir."/".$ref_name.(pop(@refgen_parts)))
            {
                $status = $status + 1;            
            }    
        }
    }
    else
    {
        $status = $status + 1;
    }
    
    if ($status != 0)
    {
        PIPELINETOOLS::PrintTask(
            "Started Generating Reference Genome For HISAT2 Alignment");
        
        my $cp_cmd = "mkdir -p ".$ref_dir;
        
        my $cmd = `$cp_cmd`;
        if ($cmd -> success() != 1)
        {
            PIPELINETOOLS::PrintStd($cmd -> merged);
            die "ERROR: mkdir\n";
        } 
        
        $cp_cmd = "cp ".$ref_fasta." ".$ref_dir;
        $cmd = `$cp_cmd`;
        if ($cmd -> success() != 1)
        {
            PIPELINETOOLS::PrintStd($cmd -> merged);
            die "ERROR: Can't move reference fasta file";
        } 
        
        $cp_cmd = "cp ".$ref_gtf." ".$ref_dir;
        $cmd = `$cp_cmd`;
        if ($cmd -> success() != 1)
        {
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            die "ERROR: Can't move reference gtf file";
        }
        
        $ref_gtf = $ref_dir."/".$ref_gtf;
        
        if ($ref_fasta =~ ".gz")
        {
            my $gunzip_cmd = `gunzip $ref_fasta`;
            if ($gunzip_cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                die "ERROR: Can't unzipt $ref_fasta !\n";
            }
            
            $ref_fasta = substr($ref_fasta,0,-3);
        }
        
        if ($ref_gtf =~ ".gz")
        {
            my $gunzip_cmd = `gunzip $ref_gtf`;
            if ($gunzip_cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> stdout);
                die "ERROR: Can't unzipt $ref_gtf !\n";
            }
            
            $ref_gtf = substr($ref_gtf,0,-3);
        }
        
        my $HISATbuild_cmd = ($::global_cfg -> param("sprograms.HISAT2")).
            "-build -q -f ".$ref_fasta.
            " ".$ref_dir."/".$ref_name;
        
        print $HISATbuild_cmd."\n";
        $cmd = `$HISATbuild_cmd`;
        if ($cmd -> success() != 1)
        {
            PIPELINETOOLS::PrintStd($cmd -> merged);
            PIPELINETOOLS::WriteLogOut(($cmd -> merged));
            die "ERROR: Can't build HISATindex!\n";
        }
        PIPELINETOOLS::WriteLogOut($cmd -> stdout);

        unlink $ref_fasta;
        unlink $ref_gtf;
        
        PIPELINETOOLS::PrintTask(
            "Finished Generating Reference Genome For STAR Alignment");
    }
    
    return;
}

#-------------------------------------------------------------------------------
# RunTophat: This function creates the command for a proper
#           call of Tophat and then starts Tophat.
#-------------------------------------------------------------------------------
sub RunTophat{
    PIPELINETOOLS::WriteLogChapter("Tophat");
    PIPELINETOOLS::PrintTask("Started Tophat");
    
    my @prefix = (($::global_cfg -> param("required.sequence_1"))."_tophat_",
        ($::global_cfg -> param("required.sequence_2"))."_tophat_");
    

    my $m = 0;
    my $sample_nr = 1;
    while ($m < ($::global_cfg -> param("required.seqlength1")))
    {
        if ($::global_cfg -> param("required.seqtype") eq "PE")
        {
            if (int($sample_nr) < 10)
            {
                $sample_nr = "0".int($sample_nr);
            }
            
            my $tophat_cmd = ($::global_cfg -> param("sprograms.TopHat2")).
                " -o ".($::global_cfg -> param("results.tmp")).
                " -p ".($::global_cfg -> param("cmdline.threads")).
                " -G ".($::global_cfg -> param("required.GenomeGTF"))." ".
                ($::global_cfg -> param("results.THindex"))." ".
                $::sequences_1[$m]." ".$::sequences_1[$m + 1];
            
            PIPELINETOOLS::PrintStd($tophat_cmd);
            
            my $cmd = `$tophat_cmd`;
            if ($cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                die "ERROR: can't call TopHat on PE ".
                    $::sequences_1[$m]." & ".$::sequences_1[$m + 1]."!\n";
            }
            
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            PIPELINETOOLS::WriteLogOut($cmd -> stdout);
            
            PIPELINETOOLS::MoveFile($::sequences_1[$m],
                ($::global_cfg -> param("results.preprocess"))."/"); 
            PIPELINETOOLS::MoveFile($::sequences_1[$m + 1],
                ($::global_cfg -> param("results.preprocess"))."/");
            
        }
        else
        {
            if (int($sample_nr) < 10)
            {
                $sample_nr = "0".int($sample_nr);
            }
            
             my $tophat_cmd = ($::global_cfg -> param("sprograms.TopHat2")).
                " -o ".($::global_cfg -> param("results.tmp")).
                " -p ".($::global_cfg -> param("cmdline.threads")).
                " -G ".($::global_cfg -> param("required.GenomeGTF"))." ".
                ($::global_cfg -> param("results.THindex"))." ".
                $::sequences_1[$m];
            
            PIPELINETOOLS::PrintStd($tophat_cmd);
            
            my $cmd = `$tophat_cmd`;
            if ($cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                die "ERROR: can't call TopHat on SE ".
                    $::sequences_1[$m]."!\n";
            }
            
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            PIPELINETOOLS::WriteLogOut($cmd -> stdout);
        
            PIPELINETOOLS::MoveFile($::sequences_1[$m],
                ($::global_cfg -> param("results.preprocess"))."/"); 
        }
        
        my @tophat_files = PIPELINETOOLS::ReadDirectory(
            $::global_cfg -> param("results.tmp"),"");
        
        while (@tophat_files)
        {
            my $f = shift(@tophat_files);
            if ($f =~ ".bam" or $f =~ ".bed")
            {
                rename (($::global_cfg -> param("results.tmp"))."/".$f,
                    ($::global_cfg -> param("results.alignment")).
                    "/".($::global_cfg -> param("required.sequence_1")).
                    "_".$sample_nr."_tophat_".$f);
            }
            elsif ($f =~ ".txt")
            {
                rename (($::global_cfg -> param("results.tmp"))."/".$f,
                    ($::global_cfg -> param("results.qreports")).
                    "/".($::global_cfg -> param("required.sequence_1")).
                    "_".$sample_nr."_tophat_".$f);    
            }    
        }
        
        if ($::global_cfg -> param("required.seqtype") eq "PE")
        {
            $m = $m + 2;
        }
        else
        {
            $m++;
        }
        
        $sample_nr++;
    }

    $m = 0;
    $sample_nr = 1;
    while ($m < ($::global_cfg -> param("required.seqlength2")))
    {
        if ($::global_cfg -> param("required.seqtype") eq "PE")
        {
            if (int($sample_nr) < 10)
            {
                $sample_nr = "0".int($sample_nr);
            }
            
            my $tophat_cmd = ($::global_cfg -> param("sprograms.TopHat2")).
                " -o ".($::global_cfg -> param("results.tmp")).
                " -p ".($::global_cfg -> param("cmdline.threads")).
                " -G ".($::global_cfg -> param("required.GenomeGTF"))." ".
                ($::global_cfg -> param("results.THindex"))." ".
                $::sequences_2[$m]." ".$::sequences_2[$m + 1];
            
            PIPELINETOOLS::PrintStd($tophat_cmd);
            
            my $cmd = `$tophat_cmd`;
            if ($cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                die "ERROR: can't call TopHat on PE ".
                    $::sequences_2[$m]." & ".$::sequences_2[$m + 1]."!\n";
            }
            
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            PIPELINETOOLS::WriteLogOut($cmd -> stdout);
            
            PIPELINETOOLS::MoveFile($::sequences_2[$m],
                ($::global_cfg -> param("results.preprocess"))."/"); 
            PIPELINETOOLS::MoveFile($::sequences_2[$m + 1],
                ($::global_cfg -> param("results.preprocess"))."/");
            
        }
        else
        {
            if (int($sample_nr) < 10)
            {
                $sample_nr = "0".int($sample_nr);
            }
            
            my $tophat_cmd = ($::global_cfg -> param("sprograms.TopHat2")).
                " -o ".($::global_cfg -> param("results.tmp")).
                " -p ".($::global_cfg -> param("cmdline.threads")).
                " -G ".($::global_cfg -> param("required.GenomeGTF"))." ".
                ($::global_cfg -> param("results.THindex"))." ".
                $::sequences_2[$m];
            
            PIPELINETOOLS::PrintStd($tophat_cmd);
            
            my $cmd = `$tophat_cmd`;
            if ($cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                die "ERROR: can't call TopHat on SE ".
                    $::sequences_2[$m]."!\n";
            }
            
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            PIPELINETOOLS::WriteLogOut($cmd -> stdout);

            PIPELINETOOLS::MoveFile($::sequences_2[$m],
                ($::global_cfg -> param("results.preprocess"))."/");          
            
        }
        
        my @tophat_files = PIPELINETOOLS::ReadDirectory(
            $::global_cfg -> param("results.tmp"),"");
        
        while (@tophat_files)
        {
            my $f = shift(@tophat_files);
            if ($f =~ ".bam" or $f =~ ".bed")
            {
                rename (($::global_cfg -> param("results.tmp"))."/".$f,
                    ($::global_cfg -> param("results.alignment")).
                    "/".($::global_cfg -> param("required.sequence_2")).
                    "_".$sample_nr."_tophat_".$f);
            }
            elsif ($f =~ ".txt")
            {
                rename (($::global_cfg -> param("results.tmp"))."/".$f,
                    ($::global_cfg -> param("results.qreports")).
                    "/".($::global_cfg -> param("required.sequence_2")).
                    "_".$sample_nr."_tophat_".$f);    
            }    
        }
        
        if ($::global_cfg -> param("required.seqtype") eq "PE")
        {
            $m = $m + 2;
        }
        else
        {
            $m++;
        }
        
        $sample_nr++;
    }

    PIPELINETOOLS::CreateSuccess("Mapping");
    PIPELINETOOLS::PrintTask("Finished Tophat");
    return;
}

#-------------------------------------------------------------------------------
# RunSTAR: This function creates the command for a proper
#           call of STAR and then starts STAR.
#-------------------------------------------------------------------------------
sub RunStar{
    PIPELINETOOLS::WriteLogChapter("STAR");
    PIPELINETOOLS::PrintTask("Started STAR");
    
    my $ref_dir = ($::global_cfg -> param("sdirectories.RawData")).
        "/STARindex/".
        $::global_cfg -> param("required.ReferenceGenome");
    
    my @prefix = (($::global_cfg -> param("required.sequence_1"))."_STAR_",
        ($::global_cfg -> param("required.sequence_2"))."_STAR_");
    
    my $m = 0;
    my $sample_nr = 1;
    while ($m < ($::global_cfg -> param("required.seqlength1")))
    {
        if (int($sample_nr) < 10)
        {
                $sample_nr = "0".int($sample_nr);
        }
            
        my $seq_dir = $::global_cfg -> param("results.tmp")."/";
        
        if ($::global_cfg -> param("required.seqtype") eq "PE")
        {  
            my $star_cmd = ($::global_cfg -> param("sprograms.STAR")).
                " --genomeDir ".$ref_dir.
                " --readFilesIn ".$::sequences_1[$m].
                " ".$::sequences_1[$m + 1].
                " ".($::global_cfg -> param("scmd.STAR")).
                " --runThreadN ".($::global_cfg -> param("cmdline.threads")).
                " --outFileNamePrefix ".
                ($::global_cfg -> param("results.tmp"))."/".
                ($::global_cfg -> param("required.sequence_1")).
                "_".$sample_nr."_STAR_";
            
            PIPELINETOOLS::PrintStd($star_cmd);
            
            my $cmd = `$star_cmd`;
            if ($cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                die "ERROR: Can't call STAR on ".
                    $::sequences_1[$m]." & ".$::sequences_1[$m + 1]."!\n";  
            }
            
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            PIPELINETOOLS::WriteLogOut($cmd -> stdout);
            
            PIPELINETOOLS::MoveFile($::sequences_1[$m],
                ($::global_cfg -> param("results.preprocess"))."/"); 
            PIPELINETOOLS::MoveFile($::sequences_1[$m + 1],
                ($::global_cfg -> param("results.preprocess"))."/");
 
        }
        else
        {
            if (int($sample_nr) < 10)
            {
                $sample_nr = "0".int($sample_nr);
            }
            
            my $star_cmd = ($::global_cfg -> param("sprograms.STAR")).
                " --genomeDir ".$ref_dir.
                " --readFilesIn ".$::sequences_1[$m].
                " ".($::global_cfg -> param("scmd.STAR")).
                " --runThreadN ".($::global_cfg -> param("cmdline.threads")).
                " --outFileNamePrefix ".
                ($::global_cfg -> param("results.tmp"))."/".
                ($::global_cfg -> param("required.sequence_1")).
                "_".$sample_nr."_STAR_";
            
            PIPELINETOOLS::PrintStd($star_cmd);
            
            my $cmd = `$star_cmd`;
            if ($cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                die "ERROR: Can't call STAR on ".
                    $::sequences_1[$m]."!\n";  
            }
            
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            PIPELINETOOLS::WriteLogOut($cmd -> stdout);
            
            PIPELINETOOLS::MoveFile($::sequences_1[$m],
                ($::global_cfg -> param("results.preprocess"))."/"); 
        }
        
        my $convert_cmd = ($::global_cfg -> param("sprograms.Samtools")).
            " view".
            " -@ ".($::global_cfg -> param("cmdline.threads")).
            " -bS".
            " ".($::global_cfg -> param("results.tmp"))."/".
            ($::global_cfg -> param("required.sequence_1")).
            "_".$sample_nr."_STAR_"."Aligned.out.sam".
            " | ".
            ($::global_cfg -> param("sprograms.Samtools"))." sort ".
            " -@ ".($::global_cfg -> param("cmdline.threads"))." - ".
            ($::global_cfg -> param("results.alignment"))."/".
            ($::global_cfg -> param("required.sequence_1")).
            "_".$sample_nr."_STAR_"."aligned";
        
        PIPELINETOOLS::PrintStd($convert_cmd);
        
        my $cmd = `$convert_cmd`;
        if ($cmd -> success() != 1)
        {
            PIPELINETOOLS::PrintStd($cmd -> merged);
            PIPELINETOOLS::WriteLogOut(($cmd -> merged));
            die "ERROR: Can't convert sam to bam!\n";  
        }             

        PIPELINETOOLS::PrintStd($cmd -> stdout);
        PIPELINETOOLS::WriteLogOut($cmd -> stdout);
        
        if ($::global_cfg -> param("required.seqtype") eq "PE")
        {
            $m = $m + 2;
        }
        else
        {
            $m++;
        }
        
        $sample_nr++;
    }

    $m = 0;
    $sample_nr = 1;
    while ($m < ($::global_cfg -> param("required.seqlength2")))
    {
        if (int($sample_nr) < 10)
        {
                $sample_nr = "0".int($sample_nr);
        }
            
        my $seq_dir = $::global_cfg -> param("results.tmp")."/";
        
        if ($::global_cfg -> param("required.seqtype") eq "PE")
        {  
            my $star_cmd = ($::global_cfg -> param("sprograms.STAR")).
                " --genomeDir ".$ref_dir.
                " --readFilesIn ".$::sequences_2[$m].
                " ".$::sequences_2[$m + 1].
                " ".($::global_cfg -> param("scmd.STAR")).
                " --runThreadN ".($::global_cfg -> param("cmdline.threads")).
                " --outFileNamePrefix ".
                ($::global_cfg -> param("results.tmp"))."/".
                ($::global_cfg -> param("required.sequence_2")).
                "_".$sample_nr."_STAR_";
            
            PIPELINETOOLS::PrintStd($star_cmd);
            
            my $cmd = `$star_cmd`;
            if ($cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                die "ERROR: Can't call STAR on ".
                    $::sequences_2[$m]." & ".$::sequences_2[$m + 1]."!\n";  
            }
            
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            PIPELINETOOLS::WriteLogOut($cmd -> stdout);
            
            PIPELINETOOLS::MoveFile($::sequences_2[$m],
                ($::global_cfg -> param("results.preprocess"))."/"); 
            PIPELINETOOLS::MoveFile($::sequences_2[$m + 1],
                ($::global_cfg -> param("results.preprocess"))."/");
 
        }
        else
        {
            my $star_cmd = ($::global_cfg -> param("sprograms.STAR")).
                " --genomeDir ".$ref_dir.
                " --readFilesIn ".$::sequences_2[$m].
                " ".($::global_cfg -> param("scmd.STAR")).
                " --runThreadN ".($::global_cfg -> param("cmdline.threads")).
                " --outFileNamePrefix ".
                ($::global_cfg -> param("results.tmp"))."/".
                ($::global_cfg -> param("required.sequence_2")).
                "_".$sample_nr."_STAR_";
            
            PIPELINETOOLS::PrintStd($star_cmd);
            
            my $cmd = `$star_cmd`;
            if ($cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                die "ERROR: Can't call STAR on ".
                    $::sequences_2[$m]."!\n";  
            }
            
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            PIPELINETOOLS::WriteLogOut($cmd -> stdout);
            
            PIPELINETOOLS::MoveFile($::sequences_2[$m],
                ($::global_cfg -> param("results.preprocess"))."/"); 
        }
        
        my $convert_cmd = ($::global_cfg -> param("sprograms.Samtools")).
            " view".
            " -@ ".($::global_cfg -> param("cmdline.threads")).
            " -bS".
            " ".($::global_cfg -> param("results.tmp"))."/".
            ($::global_cfg -> param("required.sequence_2")).
            "_".$sample_nr."_STAR_"."Aligned.out.sam".
            " | ".
            ($::global_cfg -> param("sprograms.Samtools"))." sort ".
            " -@ ".($::global_cfg -> param("cmdline.threads"))." - ".
            ($::global_cfg -> param("results.alignment"))."/".
            ($::global_cfg -> param("required.sequence_2")).
            "_".$sample_nr."_STAR_"."aligned";
        
        PIPELINETOOLS::PrintStd($convert_cmd);
        
        my $cmd = `$convert_cmd`;
        if ($cmd -> success() != 1)
        {
            PIPELINETOOLS::PrintStd($cmd -> merged);
            PIPELINETOOLS::WriteLogOut(($cmd -> merged));
            die "ERROR: Can't convert sam to bam!\n";  
        }             

        PIPELINETOOLS::PrintStd($cmd -> stdout);
        PIPELINETOOLS::WriteLogOut($cmd -> stdout);
        
        
        if ($::global_cfg -> param("required.seqtype") eq "PE")
        {
            $m = $m + 2;
        }
        else
        {
            $m++;
        }
        
        $sample_nr++;
    }    
    
    PIPELINETOOLS::CreateSuccess("Mapping");
    PIPELINETOOLS::PrintTask("Finished STAR");
    
    return;
}

#-------------------------------------------------------------------------------
# RunHISAT: This function creates the command for a proper
#           call of Tophat and then starts Tophat.
#-------------------------------------------------------------------------------
sub RunHISAT{
    PIPELINETOOLS::WriteLogChapter("HISAT");
    PIPELINETOOLS::PrintTask("Started HISAT2");
    
    my @prefix = (($::global_cfg -> param("required.sequence_1"))."_hisat2_",
        ($::global_cfg -> param("required.sequence_2"))."_hisat2_");
    

    my $m = 0;
    my $sample_nr = 1;
    while ($m < ($::global_cfg -> param("required.seqlength1")))
    {
        if (int($sample_nr) < 10)
        {
            $sample_nr = "0".int($sample_nr);
        }
            
        if ($::global_cfg -> param("required.seqtype") eq "PE")
        {
            
            my $hisat_cmd = ($::global_cfg -> param("sprograms.HISAT2")).
                " -p ".($::global_cfg -> param("cmdline.threads")).
                " -x ".($::global_cfg -> param("results.HISATindex")).
                " --sp 1000,1000".
                " -1 ".$::sequences_1[$m].
                " -2 ".$::sequences_1[$m + 1].
                " | ".($::global_cfg -> param("sprograms.Samtools")).
                " view ".
                "-@ ".($::global_cfg -> param("cmdline.threads")).
                " -bS -".
                " | ".($::global_cfg -> param("sprograms.Samtools")).
                " sort ".
                "-@ ".($::global_cfg -> param("cmdline.threads")).
                " - ".($::global_cfg -> param("results.alignment"))."/".
                $prefix[0].$sample_nr;
                
            PIPELINETOOLS::PrintStd($hisat_cmd);
            
            my $cmd = `$hisat_cmd`;
            if ($cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                die "ERROR: can't call HISAT on PE ".
                    $::sequences_1[$m]." & ".$::sequences_1[$m + 1]."!\n";
            }
            
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            PIPELINETOOLS::WriteLogOut($cmd -> stdout);
            
            PIPELINETOOLS::MoveFile($::sequences_1[$m],
                ($::global_cfg -> param("results.preprocess"))."/"); 
            PIPELINETOOLS::MoveFile($::sequences_1[$m + 1],
                ($::global_cfg -> param("results.preprocess"))."/");
            
        }
        else
        {
            
            my $hisat_cmd = ($::global_cfg -> param("sprograms.HISAT2")).
                " -p ".($::global_cfg -> param("cmdline.threads")).
                " -x ".($::global_cfg -> param("results.HISATindex")).
                " -U ".$::sequences_1[$m].
                " | ".($::global_cfg -> param("sprograms.Samtools")).
                " view ".
                "-@ ".($::global_cfg -> param("cmdline.threads")).
                " -bS -".
                " | ".($::global_cfg -> param("sprograms.Samtools")).
                " sort ".
                "-@ ".($::global_cfg -> param("cmdline.threads")).
                " - ".($::global_cfg -> param("results.alignment"))."/".
                $prefix[0].$sample_nr;
            
            PIPELINETOOLS::PrintStd($hisat_cmd);
            
            my $cmd = `$hisat_cmd`;
            if ($cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                die "ERROR: can't call HISAT on SE ".
                    $::sequences_1[$m]."!\n";
            }
            
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            PIPELINETOOLS::WriteLogOut($cmd -> stdout);
        
            PIPELINETOOLS::MoveFile($::sequences_1[$m],
                ($::global_cfg -> param("results.preprocess"))."/"); 
        }
        
        if ($::global_cfg -> param("required.seqtype") eq "PE")
        {
            $m = $m + 2;
        }
        else
        {
            $m++;
        }
        
        $sample_nr++;
    }

    $m = 0;
    $sample_nr = 1;
    while ($m < ($::global_cfg -> param("required.seqlength2")))
    {
        if (int($sample_nr) < 10)
        {
            $sample_nr = "0".int($sample_nr);
        }
            
        if ($::global_cfg -> param("required.seqtype") eq "PE")
        {
            my $hisat_cmd = ($::global_cfg -> param("sprograms.HISAT2")).
                " -p ".($::global_cfg -> param("cmdline.threads")).
                " -x ".($::global_cfg -> param("results.HISATindex")).
                " --sp 1000,1000".
                " -1 ".$::sequences_2[$m].
                " -2 ".$::sequences_2[$m + 1].
                " | ".($::global_cfg -> param("sprograms.Samtools")).
                " view ".
                "-@ ".($::global_cfg -> param("cmdline.threads")).
                " -bS -".
                " | ".($::global_cfg -> param("sprograms.Samtools")).
                " sort ".
                "-@ ".($::global_cfg -> param("cmdline.threads")).
                " - ".($::global_cfg -> param("results.alignment"))."/".
                $prefix[1].$sample_nr;
            
            PIPELINETOOLS::PrintStd($hisat_cmd);
            
            my $cmd = `$hisat_cmd`;
            if ($cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                die "ERROR: can't call HISAT on PE ".
                    $::sequences_2[$m]." & ".$::sequences_2[$m + 1]."!\n";
            }
            
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            PIPELINETOOLS::WriteLogOut($cmd -> stdout);
            
            PIPELINETOOLS::MoveFile($::sequences_2[$m],
                ($::global_cfg -> param("results.preprocess"))."/"); 
            PIPELINETOOLS::MoveFile($::sequences_2[$m + 1],
                ($::global_cfg -> param("results.preprocess"))."/");
            
        }
        else
        {
            my $hisat_cmd = ($::global_cfg -> param("sprograms.HISAT2")).
                " -p ".($::global_cfg -> param("cmdline.threads")).
                " -x ".($::global_cfg -> param("results.HISATindex")).
                " -U ".$::sequences_2[$m].
                " | ".($::global_cfg -> param("sprograms.Samtools")).
                " view ".
                "-@ ".($::global_cfg -> param("cmdline.threads")).
                " -bS -".
                " | ".($::global_cfg -> param("sprograms.Samtools")).
                " sort ".
                "-@ ".($::global_cfg -> param("cmdline.threads")).
                " - ".($::global_cfg -> param("results.alignment"))."/".
                $prefix[1].$sample_nr;
            
            PIPELINETOOLS::PrintStd($hisat_cmd);
            
            my $cmd = `$hisat_cmd`;
            if ($cmd -> success() != 1)
            {
                PIPELINETOOLS::PrintStd($cmd -> merged);
                PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                die "ERROR: can't call HISAT on SE ".
                    $::sequences_2[$m]."!\n";
            }
            
            PIPELINETOOLS::PrintStd($cmd -> stdout);
            PIPELINETOOLS::WriteLogOut($cmd -> stdout);

            PIPELINETOOLS::MoveFile($::sequences_2[$m],
                ($::global_cfg -> param("results.preprocess"))."/");          
            
        }
        
        if ($::global_cfg -> param("required.seqtype") eq "PE")
        {
            $m = $m + 2;
        }
        else
        {
            $m++;
        }
        
        $sample_nr++;
    }

    PIPELINETOOLS::CreateSuccess("Mapping");
    PIPELINETOOLS::PrintTask("Finished HISAT");
    return;
}

#-------------------------------------------------------------------------------
# QualiMap: Creates an RNA-seq QC of a *.bam file.
#           Input: *.bam - file
#-------------------------------------------------------------------------------
sub QualiMap{
    PIPELINETOOLS::WriteLogChapter("QualiMap");
    PIPELINETOOLS::PrintTask("Started QualiMap");
    
    my $out_file = "";
    
    my @alignments = PIPELINETOOLS::ReadDirectory(
        $::global_cfg -> param("results.alignment"),".bam");   
    
    if (@alignments)
    {

        
        while (@alignments)
        {
            my $tmp = shift(@alignments);
            my $pdfname = "";
            $tmp = ($::global_cfg -> param("results.alignment"))."/".$tmp;
            
            
            if ($tmp !~ ".bai")
            {
                my $filename = substr($tmp,0,-4);
                
                my $seqtypename;
                my $alignnumber = 1;
                
                if ($filename =~ ($::global_cfg -> param("required.sequence_1")))
                {
                    my $exit = 0;
                    while ($exit == 0)
                    {
                        if ($alignnumber < 10)
                        {
                            $alignnumber = "0".$alignnumber;
                        }
                        
                        $pdfname = ($::global_cfg -> param("required.sequence_1")).
                            "_".$alignnumber;
                            
                        if ($filename =~ $pdfname)
                        {
                            $exit++;
                        }
                        else
                        {
                            $alignnumber = int($alignnumber) + 1;       
                        }
                        
                    }
                }
                else
                {
                    my $exit = 0;
                    while ($exit == 0)
                    {
                        if ($alignnumber < 10)
                        {
                            $alignnumber = "0".$alignnumber;
                        }
                        
                        $pdfname = ($::global_cfg -> param("required.sequence_2")).
                            "_".$alignnumber;
                            
                        if ($filename =~ $pdfname)
                        {
                            $exit++;
                        }
                        else
                        {
                            $alignnumber = int($alignnumber) + 1;       
                        }
                        
                    }                    
                }
                
                
                if (($::global_cfg -> param("required.seqtype")) eq "PE")
                {
                    my $qualimap_cmd =
                        ($::global_cfg -> param("sprograms.QualiMap")).
                        " rnaseq".
                        " -a uniquely-mapped-reads".
                        " -bam ".$tmp.
                        " -gtf ".($::global_cfg -> param("required.GenomeGTF")).
                        " -outformat PDF".
                        " -outfile ".$pdfname."_QualiMapReport.pdf".
                        " -outdir ".($::global_cfg -> param("results.qreports")). 
                        " -pe";
                    
                    my $cmd = system($qualimap_cmd);
                    
                    #if ($cmd -> success() != 1)
                    #{
                    #    PIPELINETOOLS::PrintStd($cmd -> merged);
                    #    PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                    #    die "ERROR: Can't create QualiMap Report from $tmp!\n";
                    #}
                    #
                    #PIPELINETOOLS::PrintStd($cmd -> stdout);
                    #PIPELINETOOLS::WriteLogOut($cmd -> stdout);
                }
                else
                {
                    my $filename = substr($tmp,0,-4);
                    
                    my $qualimap_cmd =
                        ($::global_cfg -> param("sprograms.QualiMap")).
                        " rnaseq".
                        " -a uniquely-mapped-reads".
                        " -bam ".$tmp.
                        " -gtf ".($::global_cfg -> param("required.GenomeGTF")).
                        " -outformat PDF".
                        " -outfile ".$pdfname."_QualiMapReport.pdf".
                        " -outdir ".($::global_cfg -> param("results.qreports"));
                    
                    my $cmd = system($qualimap_cmd);    
                    #my $cmd = `$qualimap_cmd`; 
                    #if ($cmd -> success() != 1)
                    #{
                    #    PIPELINETOOLS::PrintStd($cmd -> merged);
                    #    PIPELINETOOLS::WriteLogOut(($cmd -> merged));
                    #    die "ERROR: Can't create QualiMap Report from $tmp!\n";
                    #}
                    
                    #PIPELINETOOLS::PrintStd($cmd -> stdout);
                    #PIPELINETOOLS::WriteLogOut($cmd -> stdout);                        
                }
            }
        }
    }
    else
    {
        die "ERROR: Can't find alignment files in".
            ($::global_cfg -> param("results.qreports"))."!\n";
    }
    
    PIPELINETOOLS::CreateSuccess("QualiMap");
    PIPELINETOOLS::PrintTask("Finished QualiMap");
    
    return;
}

1;